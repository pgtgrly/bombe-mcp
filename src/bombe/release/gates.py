"""Release gate evaluation for benchmark and workflow metrics."""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Any


SUITE_THRESHOLDS: dict[str, dict[str, tuple[str, float]]] = {
    "index": {
        "full_index_ms_p95": ("max", 30000.0),
    },
    "incremental": {
        "incremental_ms_p95": ("max", 500.0),
    },
    "query": {
        "search_ms_p95": ("max", 20.0),
        "references_ms_p95": ("max", 120.0),
        "context_ms_p95": ("max", 700.0),
    },
    "workflow_gates": {
        "workflow_a_flow_precision": ("min", 0.90),
        "workflow_a_latency_ms_p95": ("max", 2000.0),
        "workflow_b_direct_recall": ("min", 0.95),
        "workflow_b_transitive_precision": ("min", 0.85),
        "workflow_b_latency_ms_p95": ("max", 2500.0),
        "workflow_c_top5_hit_rate": ("min", 0.95),
        "workflow_c_latency_ms_p95": ("max", 1200.0),
        "workflow_d_seed_hit_rate": ("min", 0.90),
        "workflow_d_connectedness": ("min", 0.80),
        "workflow_d_latency_ms_p95": ("max", 1800.0),
    },
}


def load_history(history_path: Path) -> list[dict[str, Any]]:
    if not history_path.exists():
        return []
    entries: list[dict[str, Any]] = []
    for line in history_path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            payload = json.loads(line)
        except json.JSONDecodeError:
            continue
        if isinstance(payload, dict):
            entries.append(payload)
    return entries


def _latest_by_suite(entries: list[dict[str, Any]]) -> dict[str, dict[str, Any]]:
    latest: dict[str, dict[str, Any]] = {}
    for entry in entries:
        suite = entry.get("suite")
        if not isinstance(suite, str):
            continue
        latest[suite] = entry
    return latest


def evaluate_release_gates(entries: list[dict[str, Any]]) -> list[str]:
    violations: list[str] = []
    latest = _latest_by_suite(entries)

    for suite, metric_rules in SUITE_THRESHOLDS.items():
        entry = latest.get(suite)
        if entry is None:
            violations.append(f"{suite}:missing_suite_metrics")
            continue
        metrics = entry.get("metrics")
        if not isinstance(metrics, dict):
            violations.append(f"{suite}:missing_metrics_payload")
            continue
        for metric_name, (mode, threshold) in metric_rules.items():
            raw_value = metrics.get(metric_name)
            if not isinstance(raw_value, (int, float)):
                violations.append(f"{suite}:{metric_name}:missing_or_non_numeric")
                continue
            value = float(raw_value)
            if mode == "min" and value < threshold:
                violations.append(f"{suite}:{metric_name}:value={value}:min={threshold}")
            if mode == "max" and value > threshold:
                violations.append(f"{suite}:{metric_name}:value={value}:max={threshold}")
    return violations


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Evaluate Bombe release gate metrics.")
    parser.add_argument(
        "--history",
        type=Path,
        default=Path(os.getenv("BOMBE_PERF_HISTORY", "/tmp/bombe-perf-history.jsonl")),
        help="Path to perf history JSONL generated by perf suites.",
    )
    return parser


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()
    entries = load_history(args.history)
    violations = evaluate_release_gates(entries)
    if violations:
        print("RELEASE_GATES=FAIL")
        for violation in violations:
            print(f"- {violation}")
        return 1
    print("RELEASE_GATES=PASS")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
